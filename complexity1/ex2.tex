\documentclass[11pt]{article} \usepackage{amssymb}
\usepackage{amsfonts} \usepackage{amsmath} \usepackage{bm}
\usepackage{latexsym} \usepackage{epsfig}
\usepackage{algorithm}
\usepackage{algorithmic}

\setlength{\textwidth}{7 in} \setlength{\textheight}{9in}
\setlength{\oddsidemargin}{-0.5in} %\setlength{\topmargin}{0in}
\setlength{\evensidemargin}{-0.5in} %\setlength{\topmargin}{0in}
%\addtolength{\textheight}{.8in} 
%\addtolength{\voffset}{-1in}
\setlength{\topmargin}{-0.5in} 

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{example}[theorem]{Example}
\newenvironment{proof}{\noindent \textbf{Proof:}}{$\Box$}

\newcommand{\ignore}[1]{}

\newcommand{\enote}[1]{} \newcommand{\knote}[1]{}
\newcommand{\rnote}[1]{}



% \newcommand{\enote}[1]{{\bf [[Elchanan:} {\emph{#1}}{\bf ]]}}
% \newcommand{\knote}[1]{{\bf [[Krzysztof:} {\emph{#1}}{\bf ]]}}
% \newcommand{\rnote}[1]{{\bf [[Ryan:} {\emph{#1}}{\bf ]]}}



\DeclareMathOperator{\Support}{Supp} \DeclareMathOperator{\Opt}{Opt}
\DeclareMathOperator{\Ordo}{\mathcal{O}}
\newcommand{\MaxkCSP}{\textsc{Max $k$-CSP}}
\newcommand{\MaxkCSPq}{\textsc{Max $k$-CSP$_{q}$}}
\newcommand{\MaxCSP}[1]{\textsc{Max CSP}(#1)} \renewcommand{\Pr}{{\bf
    P}} \renewcommand{\P}{{\bf P}} \newcommand{\Px}{\mathop{\bf P\/}}
\newcommand{\E}{{\bf E}} \newcommand{\Cov}{{\bf Cov}}
\newcommand{\Var}{{\bf Var}} \newcommand{\Varx}{\mathop{\bf Var\/}}

\newcommand{\bits}{\{-1,1\}}

\newcommand{\nsmaja}{\textstyle{\frac{2}{\pi}} \arcsin \rho}

\newcommand{\Inf}{\mathrm{Inf}} \newcommand{\I}{\mathrm{I}}
\newcommand{\J}{\mathrm{J}}

\newcommand{\eps}{\epsilon} \newcommand{\lam}{\lambda}

% \newcommand{\trunc}{\ell_{2,[-1,1]}}
\newcommand{\trunc}{\zeta} \newcommand{\truncprod}{\chi}

\newcommand{\N}{\mathbb N} \newcommand{\R}{\mathbb R}
\newcommand{\Z}{\mathbb Z} \newcommand{\CalE}{{\mathcal{E}}}
\newcommand{\CalC}{{\mathcal{C}}} \newcommand{\CalM}{{\mathcal{M}}}
\newcommand{\CalR}{{\mathcal{R}}} \newcommand{\CalS}{{\mathcal{S}}}
\newcommand{\CalV}{{\mathcal{V}}}
\newcommand{\CalX}{{\boldsymbol{\mathcal{X}}}}
\newcommand{\CalG}{{\boldsymbol{\mathcal{G}}}}
\newcommand{\CalH}{{\boldsymbol{\mathcal{H}}}}
\newcommand{\CalY}{{\boldsymbol{\mathcal{Y}}}}
\newcommand{\CalZ}{{\boldsymbol{\mathcal{Z}}}}
\newcommand{\CalW}{{\boldsymbol{\mathcal{W}}}}
\newcommand{\CalF}{{\mathcal{Z}}}
% \newcommand{\boldG}{{\boldsymbol G}}
% \newcommand{\boldQ}{{\boldsymbol Q}}
% \newcommand{\boldP}{{\boldsymbol P}}
% \newcommand{\boldR}{{\boldsymbol R}}
% \newcommand{\boldS}{{\boldsymbol S}}
% \newcommand{\boldX}{{\boldsymbol X}}
% \newcommand{\boldB}{{\boldsymbol B}}
% \newcommand{\boldY}{{\boldsymbol Y}}
% \newcommand{\boldZ}{{\boldsymbol Z}}
% \newcommand{\boldV}{{\boldsymbol V}}
\newcommand{\boldi}{{\boldsymbol i}} \newcommand{\boldj}{{\boldsymbol
    j}} \newcommand{\boldk}{{\boldsymbol k}}
\newcommand{\boldr}{{\boldsymbol r}}
\newcommand{\boldsigma}{{\boldsymbol \sigma}}
\newcommand{\boldupsilon}{{\boldsymbol \upsilon}}
\newcommand{\hone}{{\boldsymbol{H1}}}
\newcommand{\htwo}{\boldsymbol{H2}}
\newcommand{\hthree}{\boldsymbol{H3}}
\newcommand{\hfour}{\boldsymbol{H4}}


\newcommand{\sgn}{\mathrm{sgn}} \newcommand{\Maj}{\mathrm{Maj}}
\newcommand{\Acyc}{\mathrm{Acyc}}
\newcommand{\UniqMax}{\mathrm{UniqMax}}
\newcommand{\Thr}{\mathrm{Thr}} \newcommand{\littlesum}{{\textstyle
    \sum}}

\newcommand{\half}{{\textstyle \frac12}}
\newcommand{\third}{{\textstyle \frac13}}
\newcommand{\fourth}{{\textstyle \frac14}}

\newcommand{\Stab}{\mathbb{S}}
\newcommand{\StabThr}[2]{\Gamma_{#1}(#2)}
\newcommand{\StabThrmin}[2]{{\underline{\Gamma}}_{#1}(#2)}
\newcommand{\StabThrmax}[2]{{\overline{\Gamma}}_{#1}(#2)}
\newcommand{\TestFcn}{\Psi}

\renewcommand{\phi}{\varphi}

\begin{document}
\title{Complexity - Exercise 2}

 \author{Omer Tamuz, 035696574}
\maketitle


\begin{enumerate}
  \item
    {\bf First Direction}
    
    Let $S$ be Cook-reducible to some sparse set $S'$. Then there exists
    a reduction $M$ that decides $S$, using an oracle for $S'$, in time
    less than some polynomial $q(n)$.

    Let 
    \begin{equation*}
    a_n=S' \cap \left(\bigcup_{k=0}^{q(n)}\{0,1\}^k\right),
    \end{equation*}
    so $a_n$ includes all the strings in $S'$ of length at most $q(n)$.

    Let $A(a_{|x|},x)$ be a machine that 
    takes advice $a_n$, so that $A$ runs the same algorithm as $M$, but
    instead of calling the oracle to decide if some $s'$ is in $S'$, it simply 
    checks if it is in $a_n$. Since $a_n$ is polynomial in length (by the
    sparcity of $S'$), and
    includes any string in $S'$ that $M$ might produce, $A$ would indeed
    decide $S$ in polynomial time.

    {\bf Second Direction}
    
    Let $S$ be in $\P/poly$, so that it is decided by a machine $A$ that takes
    advice $a_n$, where $a_n$ is of polynomial length. Let
    $S'$ is equal the set of pairs $(n, b_n$), where $b_n$ is a prefix of
    $a_n$. Then $S'$ is clearly sparse.
    
    Let $M$ be a machine that has an oracle for $S'$. Given an input $s$, 
    of length $n$, $M$ greedily builds $a_n$, then calls $A$ with $s$ and
    advice $a_n$. Hence $M$ is a cook reduction of $S$ to $S'$.
    
  \item
    
    \begin{enumerate}
    \item Let $F_n \subseteq \{0,1\}^n$ be the preimage of one in $f$. Let $\phi$ be 
      the following DNF expression:
      \begin{equation*}
        \phi(t)=\bigvee_{s\in F_n}\bigwedge_{i=1}^nt_i \leftrightarrow s_i
      \end{equation*}
      where $t_i \leftrightarrow s_i$ stands for $t_i$ when $s_i=1$, and for
      $\neg t_i$ when $s_i=0$. Then $\phi$ clearly equals $f$.

      Let $C$ be a circuit that implements $\phi$. $C$ has a wire from
      each input node to at most $2^n$ AND gates, then a wire from each AND
      gate to a single OR gate. Hence $C$ has at most 
      $2\cdot 2^n \cdot n$ wires.

    \item The number of functions from $\{0,1\}^n$ to $\{0,1\}$ is $2^{2^n}$.
      The circuits
      of size $s=2^n/(c_1\cdot n)$ can be represented by a number of bits which is
      \begin{eqnarray*}
        l_n&=&c_1\cdot s\cdot \log s
        \\ &=& c_1\cdot 2^n/(c_1\cdot n)\cdot \log \left(2^n/(c_1\cdot n)\right)
        \\ &=& 2^n/n\cdot \left(n - \log \left(c_1\cdot n\right)\right)
        \\ &=& 2^n - 2^n/n\cdot \log \left(c_1\cdot n\right)
        \\ &<& 2^n.
      \end{eqnarray*}
      Hence there are strictly less than $2^{2^n}$ circuits of size
      $2^n/(c_1\cdot n)$. Since every circuit of size less than $2^n/(c_1\cdot n)$ is
      equivalent to some circuit of that size (e.g., add parallel wires), 
      there must be a function
      from $\{0,1\}^n$ to $\{0,1\}$ that cannot be represented by a
      circuit of size $2^n/(c_1\cdot n)$.

      \item
        Let $c_2$ be some constant.
        Given $n$ and $s_1$ and $s_2$ such that 
        $c_2 \cdot s_2\log^2s_s\leq s_1\leq 2^n$, let $k$ be such that $s_2=2^k/(c_1k)$. 
        Then there exist function from $\{0,1\}^k$ to $\{0,1\}$ that cannot
        be computed by a circuit of size $s_2$. However,
        \begin{eqnarray*}
          s_1&\geq& c_2 \cdot s_2\log^2s_s
          \\ &\geq& c_22^k/(c_1k) \cdot \log^2\left(2^k/(c_1k)\right)
          \\ &\geq& c_22^k/(c_1k) \cdot \left(k-\log(c_1k)\right)^2
          \\ &\geq& (c_2/c_1)2^kk - c_22^k/(c_1k)\cdot\left(k\log(c_1k)-\log^2(c_1k)\right)^2
          \\ &\geq& (c_2/c_1)2^kk
        \end{eqnarray*}
        For large enough values, $k\log(c_1k)\geq \log^2(c_1k)$ and hence
        \begin{equation*}
          s_1 \geq (c_2/c_1)2^kk,
        \end{equation*}
        So there exists a value for $c_2$ such that all these functions
        can be computed by circuits of size $s_1$.


    \end{enumerate}
    

  \item
    \begin{enumerate}
    \item 
      {\bf First Direction}

      Let $S\in\Sigma_{k+1}$. Then there exists a polynomial $p(n)$ and a
      turing machine $V$ such that
      \begin{equation*}
        S=\{x|\exists y_{k+1}\in\{0,1\}^{p(|x|)}\forall y_k\in\{0,1\}^{p(|x|)}\cdots Q_1y_1\in\{0,1\}^{p(|x|)}V(x,y_1,\ldots,y_{k+1}) \;\mbox{accepts}\}
      \end{equation*}
      Let $S'$ be
      \begin{equation*}
        S'=\{(x,y_{k+1})|\forall y_k\in\{0,1\}^{p(|x|)}\exists y_{k-1}\in\{0,1\}^{p(|x|)}\cdots Q_1y_1\in\{0,1\}^{p(|x|)}V(x,y_1,\ldots,y_k,y_{k+1}) \;\mbox{accepts}\}
      \end{equation*}
      Then by definition $S'$ is in $\Pi_k$, and 
      \begin{equation*}
        S=\{x|\exists y:\; (x,y)\in S'\;\mbox{and}\;y\in\{0,1\}^{p(|x|)}\}
      \end{equation*}
      
      {\bf Second Direction}
      
      Let 
      \begin{equation*}
        S=\{x|\exists y:\; (x,y)\in S'\;\mbox{and}\;y\in\{0,1\}^{p(|x|)}\}
      \end{equation*}
      such that $p(n)$ a polynomial and $S'$ a set in $\Pi_k$. Then there exists
      a Turing machine $V$ and a polynomial $q(n)$ such that
      \begin{equation*}
        S'=\{(x,y_{k+1})|\forall y_k\in\{0,1\}^{q(|x|)}\exists y_{k-1}\in\{0,1\}^{q(|x|)}\cdots Q_1y_1\in\{0,1\}^{q(|x|)}V(x,y_1,\ldots,y_k,y_{k+1}) \;\mbox{accepts}\}
      \end{equation*}
      Let $r(n)=\max(p(n),q(n))$. Then $r(n)$ is a polynomial (or bound by one) and
      \begin{equation*}
        S=\{x|\exists y_{k+1}\forall y_k\cdots Q_1y_1V(x,y_1,\ldots,y_{k+1}) \;\mbox{accepts and }\; \forall i\leq k+1, y_i\in\{0,1\}^{r(|x|)}\}
      \end{equation*}.
      Hence $S$ is by definition in $\Sigma_{k+1}$.

    \item
      Let $k>0$ be such that $\Sigma_k=\Pi_k$. Let $S$ be a set in $\Sigma_{k+1}$. Then,
      by the previous question,
      there exist a set $S'$ in $\Pi_k$ and a polynomial  $p$
      such that 
      \begin{equation*}
        S=\{x|\exists y:\; (x,y)\in S'\;\mbox{and}\;y\in\{0,1\}^{p(|x|)}\}.
      \end{equation*}
      
      Since $\Pi_k=\Sigma_k$, then $S'$ is also in $\Sigma_k$, and there exists a polytime machine
      $U$ and a polynomial $q$ such that 
      \begin{equation*}
        S'=\{(x,y_{k+1})|\exists y_k\in\{0,1\}^{q(|x|)}\forall y_{k-1}\in\{0,1\}^{q(|x|)}\cdots Q_1y_1\in\{0,1\}^{q(|x|)}U(x,y_1,\ldots,y_k,y_{k+1}) \;\mbox{accepts}\},
      \end{equation*}
      
      Let $r(n)=\max(q(n),p(n))$. Then $S$ can be written as 
      \begin{eqnarray*}
        S  &=&\{x|\exists y:\; (x,y)\in S'\;\mbox{and}\;y\in\{0,1\}^{p(|x|)}\}.
        \\ &=&\{x|\exists y_{k+1}y_k\in\{0,1\}^{r(|x|))}\forall y_{k-1}\in\{0,1\}^{r(|x|))}\cdots Q_1y_1\in\{0,1\}^{r(|x|))}U(x,y_1,\ldots,y_k,y_{k+1}) \;\mbox{accepts}\},
      \end{eqnarray*}
      and so $S$ is clearly in $\Sigma_k$. Since $\Sigma_{k+1}$ includes
      $\Sigma_k$, we've shown that they are equal.
      This argument can now be applied
      inductively to show that for all $n\geq k$, it holds that 
      $\Sigma_n=\Sigma_k$. Since ${\bf PH}=\bigcup_n\Sigma_n$, and since $\Sigma_k$ includes $\Sigma_n$ for
      $n<k$, we've shown that
      ${\bf PH}$ is equal to $\Sigma_k$.

      \item
        We would like to show that ${\bf NP}^{\Pi_k}\subseteq \Sigma_{k+1}$. 
        Let $S\in {\bf NP}^{\Pi_k}$, so that there exists a set $S_1\in\Pi_k$, a
        polynomial $p(n)$ and
        a polytime machine with an oracle for $S_1$, $V^{S_1}$, such that
        \begin{equation*}
          S=\{x|\exists y\in\{0,1\}^{p(|x|)}\;\mbox{s.t.}\;V^{S_1}(x,y) \;\mbox{accepts}\}.
        \end{equation*}
        Let the running time of $V^{S_1}$ be bounded by $r(|x|)$.


        Since $S_1\in\Pi_k$, then by definition there exists a polynomial 
        $q(n)$ and a polytime machine $U$ such that
        \begin{equation*}
          S_1=\{x|\forall z_k\in\{0,1\}^{q(|x|)}\exists z_{k-1}\in\{0,1\}^{q(|x|)}\cdots Q_1z_1\in\{0,1\}^{q(|x|)}U(x,z_1,\ldots,z_k) \;\mbox{accepts}\}.
        \end{equation*}

        
        We will now build a ``verifier'' of $V^{S_1}$. Let $m < r(|x|)$.
        Let $Z=\{z_i^j\}$ be a $k$-by-$m$ matrix of strings in 
        $\{0,1\}^{q(|x|)}$. Denote
        by $z_i$ the $i$'th row of $Z$, and by $z^j$ the $j$'th column of $Z$.
        Let $H$ and $Q$ be vectors length $m$ of strings in $\{0,1\}^{q(|x|)}$. Let $A$ be 
        a binary vector of length $m$. Note that all these are polynomial
        in $|x|$.

        Let $W$ be the following TM: $W$ gets as input $x,y,Q,A,H,Z$. It runs
        an emulation of $V^{S_1}$ on input $(x,y)$, but instead of making a 
        query $q_i$ to the oracle, it runs $U(q_i,z_k^i,\ldots,z_1^i)$ 
        if $a_i=1$ and 
        $U(q_i,h_i,z_k^i,\ldots,z_2^i)$ if $a_i=0$. If
        $U$ returns $a_i$ it continues, and if not it stops and rejects. If the
        end of the emulation is reached then it returns what $V^{S_1}(x,y)$ 
        would have returned. 

        We would like to show that
        \begin{equation*}
          S=\{x | \exists y,Q,A,H\forall z_k \exists z_{k-1} \cdots Q_1z_1 
                     W(x,y,Q,A,Z,H)\}.
        \end{equation*}
        which would prove that $S$ is in $\Sigma_{k+1}$, since all the arguments
        of the $k+1$ quantifiers are polynomial in length. This
        follows quiet simply from the definitions. Assume that for some
        $x$ indeed 
        $\exists y,Q,A,H\forall z_k \exists z_{k-1} \cdots Q_1z_1 W(x,y,Q,A,Z,H)$. Then the verifier would indeed
        verify that there exists a $y$ such that $V^{S_1}$ accepts 
        $(x,y)$. Conversely, given an $x$ in $S$, we know that there exist
        $y,Q,A$ such that $V^{S_1}(x,y)$ accepts, makes queries $q_i$ and
        gets responses $a_i$. For all the $i$'s for which $a_i=1$, since $q_i\in S_1$,
        then indeed for all $z_k^i$ there exists... such that $U(q_i,z^i)$
        accepts. For all the $i$'s for which $a_i=0$, since $q_i\not\in S_1$, 
        there exists an $h_i$ such that for all $z_k^i$ there exists a $z_{k-1}^i$...
        such that $U(q_i,h_i,z_{k}^i,\ldots,z_2^i)$ rejects.
        
        




    \end{enumerate}
    

\end{enumerate}
\end{document}


