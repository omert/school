\documentclass[11pt]{article} \usepackage{amssymb}
\usepackage{amsfonts} \usepackage{amsmath} \usepackage{bm}
\usepackage{latexsym} \usepackage{epsfig}

\setlength{\textwidth}{6.5 in} \setlength{\textheight}{8.25in}
\setlength{\oddsidemargin}{0in} \setlength{\topmargin}{0in}
\addtolength{\textheight}{.8in} \addtolength{\voffset}{-.5in}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{example}[theorem]{Example}
\newenvironment{proof}{\noindent \textbf{Proof:}}{$\Box$}

\newcommand{\ignore}[1]{}

\newcommand{\enote}[1]{} \newcommand{\knote}[1]{}
\newcommand{\rnote}[1]{}



% \newcommand{\enote}[1]{{\bf [[Elchanan:} {\emph{#1}}{\bf ]]}}
% \newcommand{\knote}[1]{{\bf [[Krzysztof:} {\emph{#1}}{\bf ]]}}
% \newcommand{\rnote}[1]{{\bf [[Ryan:} {\emph{#1}}{\bf ]]}}



\DeclareMathOperator{\Support}{Supp} \DeclareMathOperator{\Opt}{Opt}
\DeclareMathOperator{\Ordo}{\mathcal{O}}
\newcommand{\MaxkCSP}{\textsc{Max $k$-CSP}}
\newcommand{\MaxkCSPq}{\textsc{Max $k$-CSP$_{q}$}}
\newcommand{\MaxCSP}[1]{\textsc{Max CSP}(#1)} \renewcommand{\Pr}{{\bf
    P}} \renewcommand{\P}{{\bf P}} \newcommand{\Px}{\mathop{\bf P\/}}
\newcommand{\E}{{\bf E}} \newcommand{\Cov}{{\bf Cov}}
\newcommand{\Var}{{\bf Var}} \newcommand{\Varx}{\mathop{\bf Var\/}}

\newcommand{\bits}{\{-1,1\}}

\newcommand{\nsmaja}{\textstyle{\frac{2}{\pi}} \arcsin \rho}

\newcommand{\Inf}{\mathrm{Inf}} \newcommand{\I}{\mathrm{I}}
\newcommand{\J}{\mathrm{J}}

\newcommand{\eps}{\epsilon} \newcommand{\lam}{\lambda}

% \newcommand{\trunc}{\ell_{2,[-1,1]}}
\newcommand{\trunc}{\zeta} \newcommand{\truncprod}{\chi}

\newcommand{\N}{\mathbb N} \newcommand{\R}{\mathbb R}
\newcommand{\Z}{\mathbb Z} \newcommand{\CalE}{{\mathcal{E}}}
\newcommand{\CalC}{{\mathcal{C}}} \newcommand{\CalM}{{\mathcal{M}}}
\newcommand{\CalR}{{\mathcal{R}}} \newcommand{\CalS}{{\mathcal{S}}}
\newcommand{\CalV}{{\mathcal{V}}}
\newcommand{\CalX}{{\boldsymbol{\mathcal{X}}}}
\newcommand{\CalG}{{\boldsymbol{\mathcal{G}}}}
\newcommand{\CalH}{{\boldsymbol{\mathcal{H}}}}
\newcommand{\CalY}{{\boldsymbol{\mathcal{Y}}}}
\newcommand{\CalZ}{{\boldsymbol{\mathcal{Z}}}}
\newcommand{\CalW}{{\boldsymbol{\mathcal{W}}}}
\newcommand{\CalF}{{\mathcal{Z}}}
% \newcommand{\boldG}{{\boldsymbol G}}
% \newcommand{\boldQ}{{\boldsymbol Q}}
% \newcommand{\boldP}{{\boldsymbol P}}
% \newcommand{\boldR}{{\boldsymbol R}}
% \newcommand{\boldS}{{\boldsymbol S}}
% \newcommand{\boldX}{{\boldsymbol X}}
% \newcommand{\boldB}{{\boldsymbol B}}
% \newcommand{\boldY}{{\boldsymbol Y}}
% \newcommand{\boldZ}{{\boldsymbol Z}}
% \newcommand{\boldV}{{\boldsymbol V}}
\newcommand{\boldi}{{\boldsymbol i}} \newcommand{\boldj}{{\boldsymbol
    j}} \newcommand{\boldk}{{\boldsymbol k}}
\newcommand{\boldr}{{\boldsymbol r}}
\newcommand{\boldsigma}{{\boldsymbol \sigma}}
\newcommand{\boldupsilon}{{\boldsymbol \upsilon}}
\newcommand{\hone}{{\boldsymbol{H1}}}
\newcommand{\htwo}{\boldsymbol{H2}}
\newcommand{\hthree}{\boldsymbol{H3}}
\newcommand{\hfour}{\boldsymbol{H4}}


\newcommand{\sgn}{\mathrm{sgn}} \newcommand{\Maj}{\mathrm{Maj}}
\newcommand{\Acyc}{\mathrm{Acyc}}
\newcommand{\UniqMax}{\mathrm{UniqMax}}
\newcommand{\Thr}{\mathrm{Thr}} \newcommand{\littlesum}{{\textstyle
    \sum}}

\newcommand{\half}{{\textstyle \frac12}}
\newcommand{\third}{{\textstyle \frac13}}
\newcommand{\fourth}{{\textstyle \frac14}}

\newcommand{\Stab}{\mathbb{S}}
\newcommand{\StabThr}[2]{\Gamma_{#1}(#2)}
\newcommand{\StabThrmin}[2]{{\underline{\Gamma}}_{#1}(#2)}
\newcommand{\StabThrmax}[2]{{\overline{\Gamma}}_{#1}(#2)}
\newcommand{\TestFcn}{\Psi}

\renewcommand{\phi}{\varphi}

\begin{document}
\title{Sublinear Algorithms - Exercises 3 and 4}

 \author{Omer Tamuz, 035696574}
\maketitle

\section{Exercise 3}
\begin{enumerate}
\item 
  \begin{enumerate}
  \item A function is a homomorphism if for all $x,y\in \Z_n$ it holds that 
    $f(x)+f(y)=f(x+y)$. Clearly then if a function is a homomorphism then
    $f(x)+f(1)=f(x+1)$. To prove the other direction, let $f$ be such that
    for all $x$ it holds that $f(x)+f(1)=f(x+1)$. Assume that 
    $f(x)+f(y)=f(x+y)$ for all $x$ and $y\in\{1,1+1,1+1+1,\ldots,y-1\}$ 
    ($y$ here can be any element of $\Z_n$ since 1 generates $\Z_n$). Then
    \begin{eqnarray*}
      f(x)+f(y)&=&f(x)+f(y-1+1)
      \\ &=& f(x)+f(y-1)+f(1)
      \\ &=& f(x+y-1)+f(1)
      \\ &=& f(x+y),
    \end{eqnarray*}
    and by induction $f(x)+f(y)=f(x+y)$ for all $x,y\in \Z_n$.
  \item
    Let $f(x)=x$ for $0\leq x\leq \lfloor n/2\rfloor$ and  
    $f(x)=x+1\mod n$ for $\lfloor n/2\rfloor\leq x < n-1$. Then $f(x)+f(1)=f(x+1)$ for all elements
    except $\lfloor n/2\rfloor$ and $n-1$, so the fraction is $1-2/n$ and certainly in
    $1-o(1)$. 

    If we pick two elements $x,y$  at random and check whether 
    $f(x)+f(y)=f(x+y)$, we would get an inequality when (for example) both
    of them are greater than $n/2$, and 
    so $\delta(f)$,  as defined in class, is at least $1/4$. 
    Therefore $f$ is certainly, again by 
    the claims we proved in class,  $1/100$-far from  being a homomorphism.
  \end{enumerate}
\item For some $\phi$, the algorithm needs to simply sample $O(\sqrt{n/\epsilon})$ 
  of the function
  values and reject iff it finds repetitions. Finding repetitions can be done in
  $O(\sqrt{n/\epsilon}\log \sqrt{n/\epsilon})$ by sorting the sample. Sampling can be done with repetitions,
  but the algorithm rejects iff it finds $i\neq j$ such that $f(i)=f(j)$.

  Clearly if the function is a bijection then the algorithm will accept.
  Assume the function is $\epsilon$-far from being a bijection. Then there exist
  at least $\epsilon n/2$ disjoint pairs of values $i,j$ such that
  $f(i)=f(j)$. 

  Let $C\sqrt{n/\epsilon}$ be the sample size.
  Consider the moment at which the $k+1$-th element of the sample was picked.
  The probability that $i_{k+1}$ is in one of the $\epsilon n/2$ pairs is 
  $\epsilon$. Conditioned on this, the probability that its pair has been
  previosuly picked is $k/n$. Hence the probability of finding a repetition 
  at this point is $\epsilon k/n$. 
  
  Conditining this on the event that no pair
  was picked up to this point only increases its probability, and so the 
  probability that no pair
  is picked in the whole sample (and so the algorithm wrongfully accepts) is
  \begin{eqnarray*}
  \P &=& \prod_{k=1}^{C\sqrt{n/\epsilon}}1-\P[\mbox{$\exists j<k, i_j\neq i_k$ s.t. $f(i_k)=f(i_j)$}|\mbox{no matching pair picked so far}]
  \\ &\leq& \prod_{k=1}^{C\sqrt{n/\epsilon}}1-\P[\mbox{$\exists j<k, i_j\neq i_k$ s.t. $f(i_k)=f(i_j)$}]
  \\ &=&\prod_{k=1}^{C\sqrt{n/\epsilon}}\left(1-{\epsilon k\over n}\right)  
  \\ &\leq& \prod_{k=1}^{C\sqrt{n/\epsilon}}\left(1-{\epsilon C\sqrt{n/\epsilon}\over n}\right)  
  \\ &\leq& \left(1-{C\over \sqrt{n/\epsilon}}\right)^{C\sqrt{n/\epsilon}}  
  \\ &\leq& e^{-C}
  \end{eqnarray*}

\end{enumerate}
\section{Exercise 4}
\begin{enumerate}
  \item 

\end{enumerate}
\end{document}


